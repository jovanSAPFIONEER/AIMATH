"""
Conjecture Generator - Creates mathematical conjectures using LLM.

This module uses LLM to generate conjectures based on:
- Selected strategy templates
- Mathematical domains
- Previous discoveries

IMPORTANT: LLM output is NEVER trusted directly.
All conjectures go through verification.
"""

import re
from typing import List, Optional, Dict, Any
from dataclasses import dataclass


@dataclass
class GeneratedConjecture:
    """A conjecture generated by the LLM."""
    statement: str              # The mathematical statement
    natural_language: str       # Human-readable description
    domain: str                 # Mathematical domain
    strategy_id: str            # Strategy used to generate
    variables: List[str]        # Variables involved
    assumptions: List[str]      # Required assumptions
    raw_response: str           # Original LLM response


class ConjectureGenerator:
    """
    Generates mathematical conjectures using LLM with strategies.
    
    Uses prompt templates from the strategy store and combines
    them with domain knowledge to generate novel conjectures.
    
    NEVER trusts the LLM output - all results must be verified.
    
    Example:
        >>> from mathclaw.providers import LLMProvider
        >>> from mathclaw.evolution import StrategyStore, DomainSelector
        >>> 
        >>> generator = ConjectureGenerator(
        ...     llm_provider=provider,
        ...     strategy_store=StrategyStore(),
        ...     domain_selector=DomainSelector(),
        ... )
        >>> 
        >>> conjecture = generator.generate()
        >>> print(conjecture.statement)  # Needs verification!
    """
    
    # System prompt emphasizing structured output
    SYSTEM_PROMPT = """You are a mathematical conjecture generator.
Your task is to generate mathematical conjectures that could be verified.

RULES:
1. Generate conjectures that can be expressed symbolically
2. Use standard mathematical notation (SymPy compatible)
3. Be precise about variable domains and assumptions
4. Focus on identities, inequalities, or patterns that can be tested

OUTPUT FORMAT:
STATEMENT: <symbolic expression or equation>
DESCRIPTION: <human-readable explanation>
VARIABLES: <comma-separated list>
ASSUMPTIONS: <domain restrictions, e.g., x > 0, n is integer>
"""

    def __init__(
        self,
        llm_provider,  # Type hint omitted to avoid circular import
        strategy_store = None,
        domain_selector = None,
    ):
        """
        Initialize the generator.
        
        Args:
            llm_provider: LLM provider for generation
            strategy_store: StrategyStore for prompt templates
            domain_selector: DomainSelector for choosing domains
        """
        self.llm = llm_provider
        self.strategy_store = strategy_store
        self.domain_selector = domain_selector
        self._last_strategy = None
        self._last_domain = None
    
    def generate(
        self,
        domain: str = None,
        strategy_id: str = None,
        context: Dict[str, Any] = None,
    ) -> Optional[GeneratedConjecture]:
        """
        Generate a mathematical conjecture.
        
        Args:
            domain: Specific domain (or auto-select)
            strategy_id: Specific strategy (or random)
            context: Additional context (e.g., recent theorems)
            
        Returns:
            GeneratedConjecture or None if generation failed
        """
        # Select domain and strategy
        if domain is None and self.domain_selector:
            selected_domain = self.domain_selector.select_domain()
            domain = selected_domain.name.lower()
        elif domain is None:
            domain = "general"
        
        if strategy_id is None and self.strategy_store:
            strategy = self.strategy_store.get_random_strategy()
            strategy_id = strategy.id
            prompt_template = strategy.prompt_template
        else:
            prompt_template = self._get_default_template()
        
        self._last_strategy = strategy_id
        self._last_domain = domain
        
        # Build the prompt
        prompt = self._build_prompt(prompt_template, domain, context)
        
        # Generate using LLM
        try:
            response = self.llm.generate(
                prompt=prompt,
                system_prompt=self.SYSTEM_PROMPT,
            )
            
            if not response:
                return None
            
            # Parse the response
            return self._parse_response(response, domain, strategy_id)
            
        except Exception as e:
            # Log but don't crash
            print(f"[ConjectureGenerator] Error: {e}")
            return None
    
    def generate_batch(
        self,
        count: int = 5,
        domain: str = None,
        diverse: bool = True,
    ) -> List[GeneratedConjecture]:
        """
        Generate multiple conjectures.
        
        Args:
            count: Number to generate
            domain: Specific domain or None for diverse
            diverse: Whether to use different strategies
            
        Returns:
            List of GeneratedConjectures
        """
        conjectures = []
        used_strategies = set()
        
        for _ in range(count):
            # Pick a different strategy each time if diverse
            strategy_id = None
            if diverse and self.strategy_store:
                available = self.strategy_store.get_all_strategies()
                for s in available:
                    if s.id not in used_strategies:
                        strategy_id = s.id
                        used_strategies.add(s.id)
                        break
            
            conjecture = self.generate(domain=domain, strategy_id=strategy_id)
            if conjecture:
                conjectures.append(conjecture)
        
        return conjectures
    
    def _build_prompt(
        self,
        template: str,
        domain: str,
        context: Dict[str, Any] = None,
    ) -> str:
        """Build the full prompt from template."""
        prompt_parts = [
            f"Mathematical domain: {domain.replace('_', ' ').title()}",
            "",
            "Task:",
            template,
        ]
        
        # Add context if provided
        if context:
            if 'recent_theorems' in context:
                prompt_parts.append("\nRecent verified theorems for inspiration:")
                for t in context['recent_theorems'][:3]:
                    prompt_parts.append(f"- {t}")
            
            if 'avoid' in context:
                prompt_parts.append("\nConjectures to avoid (already tested):")
                for a in context['avoid'][:5]:
                    prompt_parts.append(f"- {a}")
        
        prompt_parts.append(
            "\nGenerate a novel mathematical conjecture following the format."
        )
        
        return '\n'.join(prompt_parts)
    
    def _parse_response(
        self,
        response: str,
        domain: str,
        strategy_id: str,
    ) -> Optional[GeneratedConjecture]:
        """Parse LLM response into structured conjecture."""
        # Extract components using patterns
        statement = self._extract_field(response, 'STATEMENT')
        description = self._extract_field(response, 'DESCRIPTION')
        variables_str = self._extract_field(response, 'VARIABLES')
        assumptions_str = self._extract_field(response, 'ASSUMPTIONS')
        
        # Statement is required
        if not statement:
            # Try to extract any equation-like pattern
            eq_match = re.search(r'([a-zA-Z0-9_\(\)\+\-\*\/\^\=\s]+\s*=\s*[a-zA-Z0-9_\(\)\+\-\*\/\^\s]+)', response)
            if eq_match:
                statement = eq_match.group(1).strip()
            else:
                return None
        
        # Clean up the statement
        statement = self._clean_statement(statement)
        
        # Parse variables
        variables = []
        if variables_str:
            variables = [v.strip() for v in variables_str.split(',')]
        else:
            # Extract from statement
            variables = self._extract_variables(statement)
        
        # Parse assumptions
        assumptions = []
        if assumptions_str:
            assumptions = [a.strip() for a in assumptions_str.split(',')]
        
        return GeneratedConjecture(
            statement=statement,
            natural_language=description or statement,
            domain=domain,
            strategy_id=strategy_id,
            variables=variables,
            assumptions=assumptions,
            raw_response=response,
        )
    
    def _extract_field(self, text: str, field: str) -> Optional[str]:
        """Extract a field value from structured response."""
        patterns = [
            rf'{field}:\s*(.+?)(?=\n[A-Z]+:|$)',
            rf'\*\*{field}\*\*:\s*(.+?)(?=\n|$)',
            rf'{field.lower()}:\s*(.+?)(?=\n|$)',
        ]
        
        for pattern in patterns:
            match = re.search(pattern, text, re.IGNORECASE | re.DOTALL)
            if match:
                return match.group(1).strip()
        
        return None
    
    def _clean_statement(self, statement: str) -> str:
        """Clean up a mathematical statement."""
        # Remove markdown formatting
        statement = re.sub(r'\*\*|\`', '', statement)
        
        # Remove LaTeX delimiters
        statement = re.sub(r'\$|\\\(|\\\)|\\\[|\\\]', '', statement)
        
        # Convert common LaTeX to SymPy
        conversions = [
            (r'\\frac\{([^}]+)\}\{([^}]+)\}', r'(\1)/(\2)'),
            (r'\\sqrt\{([^}]+)\}', r'sqrt(\1)'),
            (r'\\sin', 'sin'),
            (r'\\cos', 'cos'),
            (r'\\tan', 'tan'),
            (r'\\log', 'log'),
            (r'\\ln', 'ln'),
            (r'\\pi', 'pi'),
            (r'\\infty', 'oo'),
            (r'\^(\{[^}]+\})', lambda m: '**' + m.group(1).strip('{}')),
            (r'\^([0-9])', r'**\1'),
        ]
        
        for pattern, replacement in conversions:
            if callable(replacement):
                statement = re.sub(pattern, replacement, statement)
            else:
                statement = re.sub(pattern, replacement, statement)
        
        return statement.strip()
    
    def _extract_variables(self, statement: str) -> List[str]:
        """Extract variables from a mathematical statement."""
        # Common single-letter variables
        common = {'x', 'y', 'z', 'a', 'b', 'c', 'n', 'm', 'k', 't', 'r', 'theta'}
        
        # Find all single letters not part of function names
        words = re.findall(r'\b([a-zA-Z])\b', statement)
        
        # Filter to likely variables
        variables = []
        for w in words:
            if w.lower() in common and w not in variables:
                variables.append(w)
        
        return variables
    
    def _get_default_template(self) -> str:
        """Get default prompt template if no strategy store."""
        return """Generate a mathematical conjecture that:
1. Is expressed as an equation or inequality
2. Involves common functions (sin, cos, exp, log, etc.)
3. Could potentially be verified symbolically
4. Is non-trivial but not impossibly complex"""
    
    @property
    def last_strategy(self) -> Optional[str]:
        """Get the last strategy used."""
        return self._last_strategy
    
    @property
    def last_domain(self) -> Optional[str]:
        """Get the last domain used."""
        return self._last_domain
